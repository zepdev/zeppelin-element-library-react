"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UploadError = void 0;

var _fs = _interopRequireDefault(require("mz/fs"));

var _nodeFetch = _interopRequireDefault(require("node-fetch"));

var _formData = _interopRequireDefault(require("form-data"));

var _isDirectory = _interopRequireDefault(require("./isDirectory"));

var _isReadable = _interopRequireDefault(require("./isReadable"));

var _readScreenshots = _interopRequireWildcard(require("./readScreenshots"));

var _getEnvironment = _interopRequireDefault(require("./getEnvironment"));

var _config = _interopRequireDefault(require("./config"));

var _display = require("./display");

var _package = _interopRequireDefault(require("../package.json"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class UploadError extends Error {}

exports.UploadError = UploadError;

async function upload(options) {
  const {
    directory,
    ignore = [],
    token: tokenOption,
    branch: branchOption,
    commit: commitOption,
    externalBuildId: externalBuildIdOption,
    batchCount: batchCountOption
  } = options;

  const token = tokenOption || _config.default.get('token');

  let environment = {};

  if (process.env.ARGOS_CLI_TEST !== 'true') {
    environment = (0, _getEnvironment.default)(process.env);
  }

  const branch = branchOption || _config.default.get('branch') || environment.branch;
  const commit = commitOption || _config.default.get('commit') || environment.commit;
  const externalBuildId = externalBuildIdOption || _config.default.get('externalBuildId') || environment.externalBuildId;
  const batchCount = batchCountOption || _config.default.get('batchCount') || environment.batchCount;

  if (environment.ci) {
    (0, _display.displayInfo)(`identified \`${environment.ci}\` environment`);
  }

  if (!token) {
    throw new UploadError('Token missing: use ARGOS_TOKEN or the --token option.');
  }

  if (!branch) {
    throw new UploadError('Branch missing: use ARGOS_BRANCH or the --branch option.');
  }

  if (!commit) {
    throw new UploadError('Commit missing: use ARGOS_COMMIT or the --commit option.');
  }

  if (!(await (0, _isDirectory.default)(directory))) {
    throw new UploadError('The path provided is not a directory.');
  }

  if (!(await (0, _isReadable.default)(directory))) {
    throw new UploadError('The path provided is not a readable, please check fs rights.');
  }

  (0, _display.displayInfo)(`using \`${branch}\` as branch`);
  (0, _display.displayInfo)(`using \`${commit}\` as commit`);
  const screenshots = await (0, _readScreenshots.default)({
    cwd: directory,
    ignore
  });

  if (screenshots.length === 0) {
    throw new UploadError(`The path provided doesn't contain any image (${_readScreenshots.GLOB_PATTERN}).`);
  }

  (0, _display.displayInfo)(`found ${screenshots.length} screenshots to upload`);
  const body = new _formData.default();
  body.append('data', JSON.stringify({
    branch,
    commit,
    token,
    externalBuildId,
    batchCount,
    names: screenshots.map(screenshot => screenshot.name)
  }));
  screenshots.reduce((body, screenshot) => {
    body.append('screenshots[]', _fs.default.createReadStream(screenshot.filename));
    return body;
  }, body);
  return (0, _nodeFetch.default)(`${_config.default.get('endpoint')}/builds`, {
    headers: {
      'X-Argos-CLI-Version': _package.default.version
    },
    method: 'POST',
    body
  });
}

var _default = upload;
exports.default = _default;